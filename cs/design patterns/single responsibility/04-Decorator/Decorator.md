# 动机
- 在某些情况下我们可能会"过度地使用继承来扩展对象的功能", 由于继承为类型引入的静态特质, 使得这种扩展方式缺乏灵活性; 并且随着子类的增多(扩展功能的增多), 各种子类的组合(扩展功能的组合)会导致更多子类的膨胀. 
- 如何使"对象功能的扩展"能够根据需要来动态地实现? 同时避免"扩展功能的增多"带来的子类膨胀问题? 从而使得任何"功能扩展变化"所导致的影响降为最低? 

# 应用场景案例
## 问题描述
- 有一个流的虚基类, 有读/写/定位3种方法
- 派生出文件流, 网络流, 内存流3种具体实现
- 每个具体实现又派生出加密需求, 形成加密文件流, 加密网络流, 加密内存流3个类. 每个流的读/写/定位业务都和非加密流相同, 每个流的读/写/定位的加密业务在3个流中都相同
- 又派生了另外的一系列类, 为缓存文件流, 缓存网络流, 缓存内存流. 情况和加密流类似
- 还可能派生出3个类的缓存加密类, 同时需要缓存和加密

## 现有方案
[代码](inherit.cpp)
现有代码的问题是编译时装配,需要在编译时就确定每个变量的类型

# 定义
# 要点总结