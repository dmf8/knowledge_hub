# 函数参数
## 默认参数
1. 默认参数需要排在形参列表的最后面
1. 函数声明和实现只能有一个地方给出默认值, 大部分场合在声明中给出
    - 如果默认参数是某些特殊的类型, 比如枚举值, 在头文件声明时看不到枚举的具体类型, 那就只能把默认值写在函数实现中
    - 如果默认参数写在了函数实现中, 函数实现必须位于调用之前. 一般这样的函数只可以类内调用. 类外调用由于头文件中的函数声明没有默认值, 如果想使用默认参数就会报错.
    - 如果声明和实现都给出默认参数, 会编译报错
1. 成员变量做默认参数
    只能用静态成员变量做默认参数. 非静态成员变量如果在函数调用前没有初始化, 就没有确定的值.

## 形参名
- 函数声明和实现可以有不同的形参名
- 函数声明可以不给出形参名, 只有形参类型
- 声明和实现的形参名不一致时, 以实现为准
- 如果函数实现也没有给出形参名, 这个参数就是一个[占位参数](#占位参数), 无法被引用

## 占位参数
- 本质上是指在函数实现中没有给出形参名的参数. 无论函数实现中有没有给出形参名. 
- 如果占位参数在函数声明中没有默认值, 就必须在调用是给出该值. 
- 占位参数可以用于辅助函数重载成不同的实现

# 函数重载
## 重载条件
- 相同
    - 函数名
    - 作用域(类/命名空间)
- 不同
    - 参数数量
        默认参数的函数和将默认参数去掉的函数无法重载, 调用会有歧义

    - 参数类型
    - 参数顺序
    - const修饰

返回值不能作为函数重载的区分条件. 函数调用时可以不接收返回值.

## extern "C"
C语言不支持函数重载. 但因为C++支持函数重载, 因此编译器会按照重载的规则重新修饰函数名. 而C语言的函数不会有这样的规则, 会导致链接时找不到c文件中的函数.

解决方法有两种, 本质上都是使用extern "C"修饰C语言的函数声明, 使其符合C++的函数修饰规则

1. 修饰头文件(推荐)
    这种方法比较通用, 不需要区分C/C++的头文件, 也不需要知道要调用的C语言函数名

    ```cpp
    #ifdef __cplusplus
    extern "C"
    {
    #endif
    //可以包含任意头文件, 包括cpp的头文件
    #include "extern_c.h"
    #ifdef __cplusplus
    }
    #endif
    ```

1. 在引用头文件之前单独声明
    ```cpp
    extern "C" void func();
    #include "extern_c.h" //包含 void func();
    ```

# 封装
## 访问控制权限
- public
- protected
- private

    私有成员是类内访问, 而非对象内访问. 如果某个函数参数是另一个同类对象的引用, 在该函数内也可以访问该对象的私有成员.

## struct/class区别
1. struct成员默认public, class成员默认private
1. struct继承默认public, class继承默认private

建议把访问权限都写完整, 不要默认使用, 便于阅读