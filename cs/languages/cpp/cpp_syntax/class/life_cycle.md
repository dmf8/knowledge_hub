# 构造析构
- 通常都写在public下, 否则外部无法调用
- 存在默认实现
    - 默认构造函数(无参)
    - 析构函数
    - 拷贝构造, 参数固定为自身对象的常量引用

- 构造函数调用方式
    1. 需要特别注意无参构造的调用方式
        ```cpp
        Person p1(18);
        Person p2 = Person();
        Person p3; //不能加括号, 加括号会认为是函数声明
        Person *pp2 = new Person();
        Person *pp3 = new Person;
        ```
        如果写成`Person p3();`会解析为函数声明, 这句话本身不会报错, 但后续用p3调用成员就会报错.

    1. C++11后的推荐方式是使用{}, 消除歧义(无参初始化和函数声明的写法会存在区别). {}可以使用在任何构造函数. 
    1. 有参构造函数任何时候都需要使用括号来传递参数

- 匿名对象

    在某一行代码运行结束后, 匿名对象就被释放了

    匿名对象的正确和错误写法
    ```cpp
    Person();
    Person(18);
    //Person(p); //这不是匿名对象, 等效于Person p;
    Person{p}; //拷贝构造匿名对象
    ```

    下面这些不是匿名对象, 而是直接调用了构造函数

    ```cpp
    Person p = Person(); //等效于Person p{};
    Person p2 = Person(19); //等效于Person p2{19};
    ```

- 拷贝构造函数

    存在以下调用时机:
    1. 用已有的对象构造新对象
    1. 值传递方式进行函数传参
    1. 以值的方式返回局部对象

        这一点, 编译器的不同优化方式下可能存在区别

- 初始化列表

    ```cpp
    Animal::Animal()
        : type(0)
    {
    }
    ```

    在类的构造函数调用之前执行, 有以下特点:
    1. 唯一能初始化const成员和引用成员的地方
    1. 调用基类构造函数的唯一方式
    1. 成员的初始化顺序是类中的声明顺序, 和初始化列表的书写顺序无关(但建议初始化列表也按声明顺序书写)

    推荐使用初始化列表构造成员变量, 如果是在构造函数中构造, 也会先调用成员的默认构造函数, 然后在构造函数中进行赋值, 造成资源浪费

- 类内初始值

    直接在类的成员变量声明的时候赋值, 相当于默认构造+赋值
    ```cpp
    int member = 0;
    ```

    需要区分类内初始值和初始化列表的区别
    1. 初始化列表的优先级更高, 如果两者都有初始值, 以初始化列表为准
    1. 如果某个成员变量在初始化列表进行了初始化, 则会忽略类内初始值的赋值操作

    推荐使用方式
    1. 相比初始化列表, 优先使用类内初始值

- explicit

    作用是强制禁止单参数构造函数的隐式转换, 包括有n个参数但存在n-1个默认参数的构造函数. 也就是说, 可以笼统地认为单参数构造函数是指只有1个未指定参数的构造函数
    如果没有使用explicit, c++的默认规定是单参数构造函数允许隐式类型转换. 隐式类型转换允许这样的实例化方式
    ```cpp
    //单参数构造函数声明
    TestExplicit(int i);

    //隐式实例化
    TestExplicit te = 2; //隐式转换, 等效于TestExplicit te = TestExplicit(2);

    //也可以直接在初始化列表中使用
    te(2)
    ```

    explicit的用法如下, 添加到单参数构造函数之前
    ```cpp
    explicit TestExplicit(int i);
    ```

# 类默认函数
- 默认函数的种类
    一个类会默认创建这些函数. 这些函数都被称为trivial的
    1. 默认构造

        当显式提供了有参构造(这里包括拷贝构造)函数之后, 就不会有默认构造函数了

    1. 拷贝构造

        默认的拷贝构造函数只是值拷贝(浅拷贝)

    1. 析构
    1. operator= 拷贝赋值
    1. 移动构造
    1. 移动赋值

- 默认函数的控制
    - =default

        要求编译器生成该函数的默认实现. 有这些使用场合:
        1. 当默认函数被抑制时, 比如显式定义了有参构造, 默认构造会被抑制
        1. 显式强调意图
        1. 保持函数trivial

    - =delete

        禁止该函数的使用, 可以禁用默认函数/普通成员函数/非成员函数
        常见的使用场景包括:
        1. 禁用拷贝/移动
        1. 禁用特定重载
        1. 禁用特定的const修饰
            ```cpp
            void func(char*);
            void func(const char*) = delete;
            ```

- trivial

    有以下特点
    1. 只是简单的逐字节拷贝, 或者不做任何事, 性能高
    1. 不调用任何用户定义的构造/析构函数
    1. 不涉及虚函数表调整
    1. 不需要初始化虚基类