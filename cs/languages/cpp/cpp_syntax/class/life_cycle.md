# 构造析构
- 通常都写在public下, 否则外部无法调用
- 存在默认实现
    - 默认构造函数(无参)
    - 析构函数
    - 拷贝构造, 参数固定为自身对象的常量引用

- 构造函数调用方式
    1. 需要特别注意无参构造的调用方式
        ```cpp
        Person p1(18);
        Person p2 = Person();
        Person p3; //不能加括号, 加括号会认为是函数声明
        Person *pp2 = new Person();
        Person *pp3 = new Person;
        ```
        如果写成`Person p3();`会解析为函数声明, 这句话本身不会报错, 但后续用p3调用成员就会报错.

    1. C++11后的推荐方式是使用{}, 消除歧义(无参初始化和函数声明的写法会存在区别). {}可以使用在任何构造函数. 
    1. 有参构造函数任何时候都需要使用括号来传递参数

- 匿名对象

    在某一行代码运行结束后, 匿名对象就被释放了

    匿名对象的正确和错误写法
    ```cpp
    Person();
    Person(18);
    Person p = Person();
    Person p2 = Person(19);
    //Person(p); //这不是匿名对象, 等效于Person p;
    Person{p}; //拷贝构造匿名对象
    ```

- 拷贝构造函数

    存在以下调用时机:
    1. 用已有的对象构造新对象
    1. 值传递方式进行函数传参
    1. 以值的方式返回局部对象

        这一点, 编译器的不同优化方式下可能存在区别

# 类默认函数
- 默认函数的种类
    一个类会默认创建这些函数. 这些函数都被称为trivial的
    1. 默认构造

        当显式提供了有参构造(这里包括拷贝构造)函数之后, 就不会有默认构造函数了

    1. 拷贝构造

        默认的拷贝构造函数只是值拷贝(浅拷贝)

    1. 析构
    1. operator= 拷贝赋值
    1. 移动构造
    1. 移动赋值

- 默认函数的控制
    - =default

        要求编译器生成该函数的默认实现. 有这些使用场合:
        1. 当默认函数被抑制时, 比如显式定义了有参构造, 默认构造会被抑制
        1. 显式强调意图
        1. 保持函数trivial

    - =delete

        禁止该函数的使用, 可以禁用默认函数/普通成员函数/非成员函数
        常见的使用场景包括:
        1. 禁用拷贝/移动
        1. 禁用特定重载
        1. 禁用特定的const修饰
            ```cpp
            void func(char*);
            void func(const char*) = delete;
            ```

- trivial

    有以下特点
    1. 只是简单的逐字节拷贝, 或者不做任何事, 性能高
    1. 不调用任何用户定义的构造/析构函数
    1. 不涉及虚函数表调整
    1. 不需要初始化虚基类