# 新增关键字
有很多, 列举一些主要的
## namespace
用于定义命名空间, 末尾不需要加分号
```cpp
namespace test_namespace
{
} 
```

命名空间有如下特点:
- 命名空间内可以有这些内容
    - 函数
    - 变量
    - 结构体/类
    - 枚举类型
- 命名空间必须定义在全局作用域下
- 命名空间可以嵌套
- 命名空间是开放的, 可以随时打开并向内部添加内容

    也可以理解成命名空间是不连续的, 分散在代码的多个位置
- 存在匿名命名空间, 有如下特点:
    1. 定义命名空间时没有名字
    1. 作用域为本文件, 其他文件无法引用, 类似static
    1. 使用时不需要加命名空间限定(也无法添加), 注意和全局命名空间的区别
- 存在全局命名空间

    如果一个对象没有定义在命名空间中, 则其位于全局命名空间, 可以用::<标识符>的方式来引用

- 命名空间可以起别名
    ```cpp
    namespace <new_name> = <old_name>;
    ```



相关概念
- 限定名qualified和非限定名unqualified

    限定名有两类: 
    1. cv-qualified, 指用const/volatile限定的标识符
    1. scope-qualified, 指用作用域限定的标识符

    除此之外, 都是非限定名

## using
作用: 
1. <a id="using推荐用法"></a>指定范围限定名的别名

    ```cpp
    using std::cout;
    ```
    
    如此使用之后, 就可以在代码中直接使用cout, 不需要写成std::cout了. 
    但如果在全局命名空间中也有cout, 直接写cout就引用不到了, 需要写成::cout

1. 引入命名空间

    ```cpp
    using namespace std;
    ```

1. 指定类别名

    ```cpp
    using <new_name> = <old_class_name>;
    ```

作用范围
using声明无法取消, 但有自身的作用范围
1. cpp文件
1. 函数内部
1. 语句块{}内部

使用建议
1. 不要在头文件使用
1. 尽量避免在cpp全局使用(类似Python一般不建议使用from module import *的写法)
1. [推荐用法](#using推荐用法)

## volatile
常和const相提并论. volatile指易变的
作用是让编译器优化时忽略该变量, 每次访问时强制从内存中重新读取该变量. 
有时优化之后, 当指令发现当前变量和之前相比未作修改, 会直接从寄存器读取该变量
代码中的写法如下
```cpp
// 两种写法等价
volatile int i = 10;
int volatile ii = 10;
```

使用场景
- 多线程编程

    当多个线程同时访问一个变量时, 可以确保每次都读取到最新的值, 而非经过编译器优化后保存在寄存器的值(寄存器中的可能是过期值)

## const(增强)

## inline
- 作用
    
    这是一个给编译器的建议, 建议将函数展开为内联函数, 不违反ODR(One Definition Rule). 但编译器不一定会强制使用内联

- 强制内联
    
    这是一种更强烈的建议, 但同样不能保证100%内联. 强制内联在不同的编译器下使用不同的关键字
    - `__forceinline`

        MSVC使用

    - `__attribute__((always_inline))`

        GCC/Clang使用

- 最佳实践
    1. 信任编译器通常比手动干预更好, 在优化模式下会自动内联很多函数
    1. 优先使用标准inline
    1. 确认信任瓶颈后再考虑使用强制内联