# class Thread
## 概述
这是一个代表独立执行线程的类. 

一个执行线程是一系列指令的集合，可以在多线程环境中和其他类似的指令集合同时执行，同时共享地址空间. 

## 线程构造
1. 有参构造
    
    ```cpp
    template <class Fn, class... Args>explicit thread (Fn&& fn, Args&&... args);
    ```
    
    参数
    - 函数指针或lambda表达式
    - 函数参数...
        - 如果函数是一个类成员函数, 那么第一个参数需要是对象的指针或引用
        - 如果函数是静态成员函数, 就不需要传入对象指针或引用, 否则会报错
        - 建议使用lambda函数的方式调用类成员函数, 这样就不需要区分是否是静态成员函数了(可以直接通过对象调用静态函数, 或者直接用命名空间写法来调用)

## 线程析构
一个线程创建后就会运行, 在退出当前作用域时会析构. 

如果直接析构一个joinable的线程, 会调用std::terminate, 导致段错误

防止段错误的方法:
1. join
1. detach

## 线程的joinable
表示线程是否可回收. 不可回收的线程有如下情况: 
1. 默认构造的线程
1. moved from
1. detach线程


    

# 成员函数



# 线程信息获取

- joinable
    
    返回线程对象是否可以被回收（合并）
    
    ```cpp
    bool joinable() const noexcept;
    ```
    
    - 可以被回收
        
        如果线程对象表示一个可以执行的线程，就可以被回收
        
    - 不可被回收
        
        有以下可能性
        - 默认构造的线程
        - 搬移构造而来
        - 线程对象的成员函数join或detach被调用
- get_id
    
    返回线程对象的id，为8B长整型变量
    
    ```cpp
    id get_id() const noexcept;
    ```
    
    只有joinable的线程会返回线程id
    
    如果已经处在一个工作线程中，需要获取当前线程的id, 使用`std::this_thread::get_id()`
    

# 线程操作

- join
    
    在线程对象执行完成后返回
    
    ```cpp
    void join();
    ```
    
    用于线程同步，调用该函数的线程会阻塞，直到join函数返回，也就是join函数所属的线程对象执行完成
    
    在调用之后，join函数所属线程会变成non-joinable，可以安全销毁
    
    - 案例
        
        创建了一个线程，执行某个函数，然后通过join等待线程完成，并回收线程
        
        ```cpp
        void count(int a, int b);
        thread th1(count, 1000, 2000);
        th1.join();
        ```
        
- detach
    
    将调用的线程对象和调用环境所处线程相分离
    
    分离后的线程独立运行，不会相互阻塞和同步。分离后的线程运行完成后，会自动回收资源
    
    ```cpp
    void detach();
    ```
    
    和join调用之后一样，函数所属的线程对象会变成non-joinable，可以安全销毁
    

# 应用

## 编译要求

编译时需要添加选项-pthread

- 案例
    
    ```bash
    g++ -pthread ../main.cpp
    ```
    
    只使用默认构造的时候不需要添加该选项，但这种情况就意味着没有对线程库进行实质性使用。因此只要用到thread库，都添加该编译选项即可
    

## 创建线程
1. 定义需要跨线程运行的函数
2. 构造线程，指定函数
3. 决定线程执行的[同步/异步方式](#线程操作)